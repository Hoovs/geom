{
package wkt

func toIfaceSlice(v interface{}) []interface{} {
    if v == nil {
        return nil
    }
    return v.([]interface{})
}

func geometryValues(exp interface{}) []interface{} {
    values := toIfaceSlice(exp)
    geometryInterfaces := make([]interface{}, 0)

    // Values always appear on index 0 and 2.
    // The grammar is: 0 -> Value, 1 -> space, 2 -> List of values
    if len(values) > 0 {
       geometryInterfaces = append(geometryInterfaces, values[0])
    }
    if len(values) > 2 {
       for _, subValue := range toIfaceSlice(values[2]) {
            // Grammar is: 0 -> Comma, 1 -> space, 2 -> Value
            geometryInterfaces = append(geometryInterfaces, toIfaceSlice(subValue)[2])
        }
    }
    return geometryInterfaces
}
}

Input <- exp:( AcceptedShapes / GeomCollectionText ) EOF {
    return exp, nil
}

AcceptedShapes <- exp:( ( "POINT" _ Point ) /
( "MULTIPOINT" _ MultiPoint ) /
( "LINESTRING" _ exp:LineString ) /
( "MULTILINESTRING" _ exp:MultiLineString ) /
( "POLYGON" _ exp:Polygon ) /
( "MULTIPOLYGON" _ exp:MultiPolygon ) ) {
    return toIfaceSlice(exp)[2], nil
}

GeomCollectionText <- "GEOMETRYCOLLECTION" _ exp:GeomCollection {
    return exp, nil
}

GeomCollection <- EmptySet {
    return (*geom.Collection)(nil), nil
} / ( LeftParen _ exp:( AcceptedShapes _ ( Comma _ AcceptedShapes )* ) RightParen ) {
    geo := make([]geom.Geometry, 0)
    for _, v := range geometryValues(exp) {
        geo = append(geo, v.(geom.Geometry))
    }
    g := geom.Collection{}
    g.SetGeometries(geo)
    return g, nil
}

MultiPolygon <- EmptySet {
    return (*geom.MultiPolygon)(nil), nil
} / ( LeftParen _ exp:( Polygon _ ( Comma _ Polygon )* ) RightParen ) {
    geo := make([][][2]float64, 0)
    for _, v := range geometryValues(exp) {
        geo = append(geo, v.(geom.MultiPoint))
    }
    g := geom.Polygon{}
    g.SetLinearRings(geo)
    return g, nil
}

Polygon <- EmptySet {
    return (*geom.Polygon)(nil), nil
} / ( LeftParen _ exp:( MultiPoint _ ( Comma _ MultiPoint )* ) RightParen ) {
    geo := make([][][2]float64, 0)
    for _, v := range geometryValues(exp) {
        geo = append(geo, v.(geom.MultiPoint))
    }
    g := geom.Polygon{}
    g.SetLinearRings(geo)
    return g, nil
}

MultiLineString <- EmptySet {
    return (*geom.MultiLineString)(nil), nil
} / ( LeftParen _ exp:( LineString _ ( Comma _ LineString )* ) RightParen ) {
    geo := make([][][2]float64, 0)
    for _, v := range geometryValues(exp) {
        geo = append(geo, v.(geom.LineString))
    }
    g := geom.MultiLineString{}
    err := g.SetLineStrings(geo)
    return g, err
}

LineString <- EmptySet {
    return (*geom.LineString)(nil), nil
} / exp:MultiPoint {
	g := geom.LineString{}
	g.SetVerticies(exp.(geom.MultiPoint))
	return g, nil
}

MultiPoint <- EmptySet {
    return (*geom.MultiPoint)(nil), nil
} / ( LeftParen _ exp:( PointTuple _ ( Comma _ PointTuple )* ) RightParen ) {
    geo := make([][2]float64, 0)
    for _, v := range geometryValues(exp) {
        geo = append(geo, v.(geom.Point))
    }
    g := geom.MultiPoint{}
    err := g.SetPoints(geo)
    return g, err
}

PointTuple <- _ first:( Number ) _ second:( Number ) _  {
    return geom.Point{first.(float64), second.(float64)}, nil
}

Point <- EmptySet {
    return (*geom.Point)(nil), nil
} / ( LeftParen _ exp:( PointTuple ) _ RightParen )  {
    return exp, nil
}

Number <- '-'? Integer ( '.' DecimalDigit+ )? {
    return strconv.ParseFloat(string(c.text), 64)
}

Integer <- '0' / NonZeroDecimalDigit DecimalDigit*
DecimalDigit <- [0-9]
NonZeroDecimalDigit <- [1-9]
_ "whitespace" <- [ \n\t\r]*
EmptySet <- "EMPTY"
LeftParen <- '('
RightParen <- ')'
Comma <- ','
EOF <- !.